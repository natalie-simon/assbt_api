name: Deploy NestJS with Prisma to OVH VPS (Optimized)

on:
  push:
    branches:
      - develop
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if no changes detected'
        required: false
        default: false
        type: boolean
      skip_tests:
        description: 'Skip pre-deployment tests'
        required: false
        default: false
        type: boolean

env:
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  pre-deploy-checks:
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check_changes.outputs.should_deploy }}
      commit_hash: ${{ steps.check_changes.outputs.commit_hash }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: develop
          fetch-depth: 2

      - name: Check for changes
        id: check_changes
        run: |
          CURRENT_COMMIT=$(git rev-parse HEAD)
          echo "commit_hash=$CURRENT_COMMIT" >> $GITHUB_OUTPUT
          
          if [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "üîÑ D√©ploiement forc√© activ√©"
            exit 0
          fi
          
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
          echo "Changed files: $CHANGED_FILES"
          
          if echo "$CHANGED_FILES" | grep -qE "\.(md|txt|yml)$|^\.github/|^docs/"; then
            if ! echo "$CHANGED_FILES" | grep -qE "\.(js|ts|json|prisma|docker)$|^src/|^prisma/"; then
              echo "should_deploy=false" >> $GITHUB_OUTPUT
              echo "‚è≠Ô∏è Seuls des fichiers non critiques ont chang√©"
              exit 0
            fi
          fi
          
          echo "should_deploy=true" >> $GITHUB_OUTPUT

      - name: Run tests
        if: ${{ github.event.inputs.skip_tests != 'true' && steps.check_changes.outputs.should_deploy == 'true' }}
        run: |
          npm ci
          npm run lint
          #npm run test

  deploy:
    needs: pre-deploy-checks
    if: needs.pre-deploy-checks.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: develop

      - name: Notify deployment start
        run: |
          if [ -n "${{ secrets.DISCORD_WEBHOOK_URL }}" ]; then
            curl -X POST "${{ secrets.DISCORD_WEBHOOK_URL }}" \
              -H 'Content-type: application/json' \
              --data "{\"embeds\":[{\"title\":\"üöÄ D√©ploiement Started\",\"description\":\"Commit: \`${{ needs.pre-deploy-checks.outputs.commit_hash }}\`\",\"color\":3447003}]}"
          fi

      - name: Deploy to OVH VPS
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.VPS_HOST }}
          username: deploy
          key: ${{ secrets.SSH_PRIVATE_KEY_OVH }}
          port: 2222
          timeout: 600s
          script: |
            set -e
            VPS_ROOT="/home/deploy/app"
            APP_DIR="${VPS_ROOT}/nestjs-prisma"
            DEPLOY_LOG="${APP_DIR}/deploy.log"
            CURRENT_COMMIT="${{ needs.pre-deploy-checks.outputs.commit_hash }}"
            
            log() {
              echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$DEPLOY_LOG"
            }
            
            deploy_failed() {
              log "‚ùå D√©ploiement √©chou√© √† l'√©tape: $1"
              if [ -n "${{ secrets.DISCORD_WEBHOOK_URL }}" ]; then
                curl -X POST "${{ secrets.DISCORD_WEBHOOK_URL }}" \
                  -H 'Content-type: application/json' \
                  --data "{\"embeds\":[{\"title\":\"‚ùå D√©ploiement Failed\",\"description\":\"Erreur: $1\\nCommit: \`$CURRENT_COMMIT\`\",\"color\":15158332}]}"
              fi
              exit 1
            }
            
            trap 'deploy_failed "Script interrompu"' ERR
            log "üöÄ D√©marrage du d√©ploiement optimis√© - Commit: $CURRENT_COMMIT"
            
            mkdir -p "$APP_DIR" "$APP_DIR/backups"
            cd "$APP_DIR"
            
            LAST_DEPLOY_COMMIT=$(cat "${APP_DIR}/.last_deploy" 2>/dev/null || echo "")
            if [ "$CURRENT_COMMIT" = "$LAST_DEPLOY_COMMIT" ] && [ "${{ github.event.inputs.force_deploy }}" != "true" ]; then
              log "‚è≠Ô∏è M√™me commit d√©tect√© ($CURRENT_COMMIT), skip du d√©ploiement"
              exit 0
            fi
            
            log "üìã Phase 1: Validation de l'environnement"
            if [ -f "${APP_DIR}/.env.dev" ]; then
              source "${APP_DIR}/.env.dev"
            fi
            
            log "üßπ Phase 2: Sauvegarde et nettoyage"
            if docker-compose -f docker-compose.prisma.yml ps -q > /dev/null 2>&1; then
              log "üíæ Sauvegarde √©tat actuel"
              docker-compose -f docker-compose.prisma.yml down
            fi
            docker rm -f postgres_db traefik api nestjs_api 2>/dev/null || true
            
            log "üì¶ Phase 3: Mise √† jour du code"
            TMP_DIR=$(mktemp -d)
            git clone --filter=blob:none --depth=1 --branch=develop https://github.com/natalie-simon/assbt_api.git "$TMP_DIR"
            cd "$APP_DIR"
            find . -mindepth 1 \
              -not -path "./backups*" \
              -not -name ".env.dev*" \
              -not -name ".last_deploy*" \
              -not -name "deploy.log*" \
              -exec rm -rf {} \; 2>/dev/null || true
            cp -R "$TMP_DIR"/* "$APP_DIR"/
            cp -R "$TMP_DIR"/.* "$APP_DIR"/ 2>/dev/null || true
            rm -rf "$TMP_DIR"
            
            log "üê≥ Phase 4: Build et d√©marrage des services"
            cd "$APP_DIR"
            docker-compose -f docker-compose.prisma.yml build --parallel || deploy_failed "√âchec du build Docker"
            docker-compose -f docker-compose.prisma.yml up -d db || deploy_failed "√âchec DB"
            
            RETRIES=20; RETRY_COUNT=0
            until docker-compose -f docker-compose.prisma.yml exec -T db pg_isready -q || [ $RETRY_COUNT -eq $RETRIES ]; do
              log "üîÑ Attente PostgreSQL... ($((RETRY_COUNT+1))/$RETRIES)"
              RETRY_COUNT=$((RETRY_COUNT+1))
              sleep 3
            done
            
            docker-compose -f docker-compose.prisma.yml up -d || deploy_failed "√âchec d√©marrage services"
            
            log "üîÑ Phase 5: Gestion avanc√©e des migrations Prisma"
            docker-compose -f docker-compose.prisma.yml exec -T api npx prisma generate || deploy_failed "√âchec generate"
            
            log "üíæ Sauvegarde de la base avant migration"
            BACKUP_FILE="backups/db_backup_$(date +%Y%m%d_%H%M%S).sql"
            docker-compose -f docker-compose.prisma.yml exec -T db pg_dump -U postgres postgres > "$BACKUP_FILE" || log "‚ö†Ô∏è √âchec sauvegarde DB"
            
            # Fonction de r√©solution intelligente des conflits
            resolve_migration_conflicts() {
              local output_file="$1"
              local retry_count="${2:-0}"
              local max_retries=3
              
              if [ $retry_count -ge $max_retries ]; then
                log "üö® Limite de tentatives atteinte ($max_retries)"
                return 1
              fi
              
              log "üîç Analyse des conflits de migration (tentative $((retry_count+1))/$max_retries)"
              
              # P3005: Base non-vide, baseline requis
              if grep -q "P3005\|schema is not empty" "$output_file"; then
                log "üîß R√©solution P3005 - Baseline automatique"
                FIRST_MIGRATION=$(docker-compose -f docker-compose.prisma.yml exec -T api sh -c "ls prisma/migrations | grep -E '^[0-9]{14}_' | head -1" | tr -d '\r\n')
                if [ -n "$FIRST_MIGRATION" ] && [ "$FIRST_MIGRATION" != "migration_lock.toml" ]; then
                  docker-compose -f docker-compose.prisma.yml exec -T api npx prisma migrate resolve --applied "$FIRST_MIGRATION"
                  return 0
                fi
              fi
              
              # P3009: Migration √©chou√©e bloquante
              if grep -q "P3009" "$output_file"; then
                log "üîß R√©solution P3009 - Migration √©chou√©e d√©tect√©e"
                FAILED_MIGRATION=$(grep -oE "The \`[0-9]{14}_[a-zA-Z0-9_]+\` migration" "$output_file" | sed 's/The `\(.*\)` migration/\1/' | head -1)
                if [ -n "$FAILED_MIGRATION" ]; then
                  log "üóëÔ∏è Marquage migration √©chou√©e comme √©chou√© puis rollback: $FAILED_MIGRATION"
                  docker-compose -f docker-compose.prisma.yml exec -T api npx prisma migrate resolve --rolled-back "$FAILED_MIGRATION" || log "‚ö†Ô∏è √âchec rollback"
                  log "üîÑ Nouvelle tentative apr√®s rollback"
                  return 0
                else
                  log "‚ö†Ô∏è Impossible d'identifier la migration √©chou√©e, reset complet"
                  docker-compose -f docker-compose.prisma.yml exec -T api npx prisma migrate reset --force --skip-seed || log "√âchec reset"
                  docker-compose -f docker-compose.prisma.yml exec -T api npx prisma db push || log "√âchec push"
                  return 2
                fi
              fi
              
              # P3018: Migration √©chou√©e
              if grep -q "P3018" "$output_file"; then
                log "üîß R√©solution P3018 - Migration √©chou√©e"
                FAILED_MIGRATION=$(grep -oE "Migration name: [0-9]{14}_[a-zA-Z0-9_]+" "$output_file" | cut -d' ' -f3 | head -1)
                [ -z "$FAILED_MIGRATION" ] && FAILED_MIGRATION=$(grep -oE "[0-9]{14}_[a-zA-Z0-9_]+" "$output_file" | head -1)
                if [ -n "$FAILED_MIGRATION" ]; then
                  log "üìå Marquage comme appliqu√©e: $FAILED_MIGRATION"
                  docker-compose -f docker-compose.prisma.yml exec -T api npx prisma migrate resolve --applied "$FAILED_MIGRATION"
                  return 0
                fi
              fi
              
              # Conflits de colonnes/tables existantes
              if grep -qE "column.*already exists|relation.*already exists|constraint.*already exists" "$output_file"; then
                log "üîß R√©solution conflit sch√©ma existant"
                PENDING_MIGRATIONS=$(docker-compose -f docker-compose.prisma.yml exec -T api npx prisma migrate status 2>&1 | grep -A10 "following migration" | grep -oE "[0-9]{14}_[a-zA-Z0-9_]+" | head -1)
                if [ -n "$PENDING_MIGRATIONS" ]; then
                  log "üìå Marquage migration conflictuelle: $PENDING_MIGRATIONS"
                  docker-compose -f docker-compose.prisma.yml exec -T api npx prisma migrate resolve --applied "$PENDING_MIGRATIONS"
                  return 0
                else
                  # Fallback: synchronisation directe
                  log "üîÑ Synchronisation directe du sch√©ma"
                  docker-compose -f docker-compose.prisma.yml exec -T api npx prisma db push --force-reset
                  return 2  # Code sp√©cial pour sch√©ma push
                fi
              fi
              
              # Autres erreurs Prisma
              if grep -qE "P[0-9]{4}" "$output_file"; then
                ERROR_CODE=$(grep -oE "P[0-9]{4}" "$output_file" | head -1)
                log "‚ö†Ô∏è Erreur Prisma d√©tect√©e: $ERROR_CODE"
                
                # Tentative de r√©solution g√©n√©rique
                LATEST_MIGRATION=$(docker-compose -f docker-compose.prisma.yml exec -T api sh -c "ls prisma/migrations | grep -E '^[0-9]{14}_' | tail -1" | tr -d '\r\n')
                if [ -n "$LATEST_MIGRATION" ] && [ "$LATEST_MIGRATION" != "migration_lock.toml" ]; then
                  log "üìå Marquage derni√®re migration: $LATEST_MIGRATION"
                  docker-compose -f docker-compose.prisma.yml exec -T api npx prisma migrate resolve --applied "$LATEST_MIGRATION"
                  return 0
                else
                  log "‚ö†Ô∏è Aucune migration valide trouv√©e, reset complet"
                  docker-compose -f docker-compose.prisma.yml exec -T api npx prisma migrate reset --force --skip-seed || log "√âchec reset"
                  docker-compose -f docker-compose.prisma.yml exec -T api npx prisma db push || log "√âchec push"
                  return 2
                fi
              fi
              
              return 1
            }
            
            # V√©rification que toutes les migrations sont appliqu√©es
            ensure_all_migrations_applied() {
              log "üîç V√©rification que toutes les migrations sont appliqu√©es"
              
              # Liste toutes les migrations disponibles
              ALL_MIGRATIONS=$(docker-compose -f docker-compose.prisma.yml exec -T api sh -c "ls prisma/migrations | grep -E '^[0-9]{14}_' | sort")
              MIGRATION_COUNT=$(echo "$ALL_MIGRATIONS" | wc -l)
              log "üìã $MIGRATION_COUNT migrations trouv√©es dans le dossier"
              
              # V√©rification du statut final
              FINAL_STATUS=$(docker-compose -f docker-compose.prisma.yml exec -T api npx prisma migrate status 2>&1)
              
              if echo "$FINAL_STATUS" | grep -q "Database schema is up to date"; then
                log "‚úÖ Toutes les migrations sont appliqu√©es"
                return 0
              elif echo "$FINAL_STATUS" | grep -q "pending migration"; then
                log "‚ö†Ô∏è Des migrations sont encore en attente"
                log "üîÑ Application forc√©e des migrations restantes"
                docker-compose -f docker-compose.prisma.yml exec -T api npx prisma migrate deploy
                return $?
              else
                log "‚ö†Ô∏è Statut unclear, v√©rification manuelle"
                # Comparaison sch√©ma actuel vs attendu
                log "üîç Synchronisation finale du sch√©ma"
                docker-compose -f docker-compose.prisma.yml exec -T api npx prisma db push --accept-data-loss
                return $?
              fi
            }
            
            # D√©ploiement avec r√©solution automatique des conflits
            deploy_with_conflict_resolution() {
              local attempt=0
              local max_attempts=5
              
              while [ $attempt -lt $max_attempts ]; do
                attempt=$((attempt + 1))
                log "üöÄ Tentative de d√©ploiement $attempt/$max_attempts"
                
                # V√©rification du statut
                MIGRATION_STATUS=$(docker-compose -f docker-compose.prisma.yml exec -T api npx prisma migrate status 2>&1)
                
                if echo "$MIGRATION_STATUS" | grep -q "Database schema is up to date"; then
                  log "‚úÖ Base de donn√©es d√©j√† √† jour"
                  ensure_all_migrations_applied
                  return $?
                fi
                
                # Tentative de d√©ploiement
                docker-compose -f docker-compose.prisma.yml exec -T api npx prisma migrate deploy 2>&1 | tee migration_attempt_$attempt.log
                
                if grep -q "successfully applied\|All migrations have been applied" migration_attempt_$attempt.log; then
                  log "‚úÖ Migrations appliqu√©es avec succ√®s"
                  rm -f migration_attempt_*.log
                  ensure_all_migrations_applied
                  return $?
                fi
                
                # R√©solution des conflits
                if resolve_migration_conflicts "migration_attempt_$attempt.log" $attempt; then
                  resolve_result=$?
                  if [ $resolve_result -eq 2 ]; then
                    log "‚úÖ Sch√©ma synchronis√© par push"
                    rm -f migration_attempt_*.log
                    ensure_all_migrations_applied
                    return $?
                  fi
                  log "üîÑ Conflit r√©solu, tentative d'application des migrations restantes"
                  
                  # Apr√®s r√©solution, tenter d'appliquer toutes les migrations
                  docker-compose -f docker-compose.prisma.yml exec -T api npx prisma migrate deploy 2>&1 | tee post_resolve_$attempt.log
                  if grep -q "successfully applied\|All migrations have been applied\|Database schema is up to date" post_resolve_$attempt.log; then
                    log "‚úÖ Migrations appliqu√©es apr√®s r√©solution"
                    rm -f migration_attempt_*.log post_resolve_*.log
                    ensure_all_migrations_applied
                    return $?
                  fi
                  rm -f post_resolve_*.log
                  continue
                else
                  log "‚ö†Ô∏è Impossible de r√©soudre le conflit √† la tentative $attempt"
                fi
                
                sleep 2
              done
              
              log "üö® √âchec apr√®s $max_attempts tentatives"
              log "üîÑ Tentative finale de synchronisation compl√®te"
              
              # Derni√®re tentative : reset + push pour garantir la coh√©rence
              docker-compose -f docker-compose.prisma.yml exec -T api npx prisma migrate reset --force --skip-seed || log "√âchec reset final"
              docker-compose -f docker-compose.prisma.yml exec -T api npx prisma db push --accept-data-loss || log "√âchec push final"
              
              # V√©rification finale
              ensure_all_migrations_applied
              final_result=$?
              
              cat migration_attempt_*.log | tail -20
              rm -f migration_attempt_*.log
              return $final_result
            }
            
            # Ex√©cution du d√©ploiement intelligent
            if deploy_with_conflict_resolution; then
              log "‚úÖ D√©ploiement des migrations r√©ussi"
            else
              deploy_failed "√âchec final du d√©ploiement des migrations"
            fi
            
            log "üîç V√©rification finale du sch√©ma"
            docker-compose -f docker-compose.prisma.yml exec -T api npx prisma migrate status || log "‚ö†Ô∏è Impossible de v√©rifier le statut final"
            
            echo "$CURRENT_COMMIT" > "${APP_DIR}/.last_deploy"
            docker image prune -f > /dev/null 2>&1
            docker volume prune -f > /dev/null 2>&1
            
            log "‚úÖ D√©ploiement termin√© avec succ√®s - Commit: $CURRENT_COMMIT"

      - name: Notify deployment success
        if: success()
        run: |
          if [ -n "${{ secrets.DISCORD_WEBHOOK_URL }}" ]; then
            curl -X POST "${{ secrets.DISCORD_WEBHOOK_URL }}" \
              -H 'Content-type: application/json' \
              --data "{\"embeds\":[{\"title\":\"‚úÖ D√©ploiement Success\",\"description\":\"Commit: \`${{ needs.pre-deploy-checks.outputs.commit_hash }}\`\\nAPI accessible\",\"color\":65280}]}"
          fi

      - name: Notify deployment failure
        if: failure()
        run: |
          if [ -n "${{ secrets.DISCORD_WEBHOOK_URL }}" ]; then
            curl -X POST "${{ secrets.DISCORD_WEBHOOK_URL }}" \
              -H 'Content-type: application/json' \
              --data "{\"embeds\":[{\"title\":\"‚ùå D√©ploiement Failed\",\"description\":\"Commit: \`${{ needs.pre-deploy-checks.outputs.commit_hash }}\`\\nVoir les logs pour plus de d√©tails\",\"color\":15158332}]}"
          fi
