name: Deploy NestJS with Prisma to OVH VPS (Dev)

on:
  workflow_dispatch:  # Permet uniquement le d√©clenchement manuel

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: dev  # Force l'utilisation de la branche dev

      - name: Deploy to OVH VPS
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.VPS_HOST }}
          username: deploy
          key: ${{ secrets.SSH_PRIVATE_KEY_OVH }}
          port: 2222  # Port SSH personnalis√©
          script: |
            # D√©finition du r√©pertoire racine sur le VPS
            VPS_ROOT="/home/deploy/app"
            APP_DIR="${VPS_ROOT}/nestjs-dev"  # R√©pertoire s√©par√© pour l'environnement dev

            # S'assurer que le r√©pertoire d'application existe
            mkdir -p ${APP_DIR}

            # V√©rifier l'√©tat actuel
            echo "üìÇ Contenu actuel du r√©pertoire de d√©ploiement:"
            ls -la ${APP_DIR}

            # Sauvegarde de la base de donn√©es si elle est en cours d'ex√©cution
            if [ -f "${APP_DIR}/docker-compose.prod.yml" ]; then
              cd ${APP_DIR}
              if docker-compose -f docker-compose.prod.yml ps postgres_db 2>&1 | grep -q "Up"; then
                echo "üì¶ Sauvegarde de la base de donn√©es..."
                mkdir -p ${APP_DIR}/backups
                CURRENT_DATE=$(date +"%Y%m%d_%H%M%S")

                # R√©cup√©ration des variables d'environnement depuis le fichier .env
                if [ -f "${APP_DIR}/.env.dev" ]; then
                  source ${APP_DIR}/.env.dev
                  DB_USER=${DB_USERNAME:-postgres}
                  DB_NAME=${DB_NAME:-Assbt}
                else
                  DB_USER="postgres"
                  DB_NAME="Assbt"
                fi

                echo "üìä Utilisation de la base de donn√©es: $DB_NAME avec l'utilisateur: $DB_USER"
                docker-compose -f docker-compose.prod.yml exec -T postgres_db pg_dump -U $DB_USER $DB_NAME > ${APP_DIR}/backups/db_${CURRENT_DATE}.sql || echo "‚ö†Ô∏è √âchec de sauvegarde, poursuite du d√©ploiement"
              fi
            fi

            # Pr√©server les fichiers importants
            cd ${APP_DIR}
            if [ -f "${APP_DIR}/.env.dev" ]; then
              echo "üíæ Sauvegarde du fichier .env.dev actuel"
              cp ${APP_DIR}/.env.dev ${APP_DIR}/.env.dev.backup
            fi

            # Copier les fichiers du d√©p√¥t
            echo "üìã Copie des fichiers du projet..."

            # Vider le r√©pertoire tout en pr√©servant les fichiers critiques
            find ${APP_DIR} -mindepth 1 -not -path "${APP_DIR}/backups*" -not -name ".env.dev" -not -name ".env.dev.backup" -not -name "docker-compose.prod.yml" -exec rm -rf {} \; 2>/dev/null || true

            # Copier tous les fichiers locaux vers le VPS
            scp -r $(pwd)/* deploy@${{ secrets.VPS_HOST }}:${APP_DIR}/

            # Gestion du fichier .env.dev
            if [ ! -f "${APP_DIR}/.env.dev" ]; then
              echo "üîç Fichier .env.dev non trouv√©, recherche d'alternatives..."

              # V√©rifier si .env.dev.backup existe
              if [ -f "${APP_DIR}/.env.dev.backup" ]; then
                echo "‚úÖ Restauration du fichier .env.dev.backup"
                cp ${APP_DIR}/.env.dev.backup ${APP_DIR}/.env.dev
              # V√©rifier si .env.dev existe dans le r√©pertoire racine
              elif [ -f "${VPS_ROOT}/.env.dev" ]; then
                echo "‚úÖ Copie du fichier .env.dev depuis ${VPS_ROOT}"
                cp ${VPS_ROOT}/.env.dev ${APP_DIR}/.env.dev
              else
                echo "‚ö†Ô∏è Aucun fichier .env.dev trouv√©! Le d√©ploiement pourrait √©chouer."
              fi
            fi

            # V√©rifier que docker-compose.prod.yml existe
            if [ ! -f "${APP_DIR}/docker-compose.prod.yml" ]; then
              echo "‚ùå Fichier docker-compose.prod.yml non trouv√©!"
              # Utiliser le fichier docker-compose.prisma.yml s'il existe
              if [ -f "${APP_DIR}/docker-compose.prisma.yml" ]; then
                echo "‚úÖ Utilisation de docker-compose.prisma.yml √† la place"
                cp ${APP_DIR}/docker-compose.prisma.yml ${APP_DIR}/docker-compose.prod.yml
              else
                exit 1
              fi
            fi

            # D√©ployer l'application
            cd ${APP_DIR}
            echo "üöÄ D√©ploiement de l'application..."
            docker-compose -f docker-compose.prod.yml down || true

            # D√©marrer d'abord la base de donn√©es seule
            echo "üîÑ D√©marrage de la base de donn√©es..."
            docker-compose -f docker-compose.prod.yml up -d db

            # Attendre que la base de donn√©es soit pr√™te
            echo "‚è≥ Attente que la base de donn√©es soit pr√™te..."
            RETRIES=20
            RETRY_COUNT=0

            until docker-compose -f docker-compose.prod.yml exec -T db pg_isready || [ $RETRY_COUNT -eq $RETRIES ]; do
              echo "üîÑ En attente de la base de donn√©es... ($RETRY_COUNT/$RETRIES)"
              RETRY_COUNT=$((RETRY_COUNT+1))
              sleep 5
            done

            if [ $RETRY_COUNT -eq $RETRIES ]; then
              echo "‚ö†Ô∏è Base de donn√©es non disponible apr√®s $RETRIES tentatives. Poursuite du d√©ploiement..."
            else
              echo "‚úÖ Base de donn√©es pr√™te"
            fi

            # D√©marrer le reste des services
            echo "üöÄ D√©marrage des autres services..."
            docker-compose -f docker-compose.prod.yml up -d --build

            # Attendre que l'API se lance
            echo "‚è≥ Attente du d√©marrage de l'API..."
            sleep 30

            # V√©rifier l'√©tat des services
            echo "üìä √âtat des services apr√®s d√©ploiement:"
            docker-compose -f docker-compose.prod.yml ps

            # Gestion des migrations avec Prisma
            if docker-compose -f docker-compose.prod.yml ps | grep -q "api"; then
              echo "üîÑ Gestion des migrations Prisma..."

              # √âtape 1: G√©n√©rer le client Prisma
              echo "üî® G√©n√©ration du client Prisma..."
              docker-compose -f docker-compose.prod.yml exec -T api npx prisma generate

              # √âtape 2: Appliquer les migrations existantes
              echo "üîÑ Application des migrations Prisma..."
              docker-compose -f docker-compose.prod.yml exec -T api npx prisma migrate deploy

              # V√©rification finale
              echo "üîç V√©rification de l'√©tat des migrations Prisma..."
              docker-compose -f docker-compose.prod.yml exec -T api npx prisma migrate status
            else
              echo "‚ö†Ô∏è Le service api n'est pas en cours d'ex√©cution, migrations ignor√©es"
            fi

            # V√©rifier les tables cr√©√©es
            echo "üìä V√©rification des tables de la base de donn√©es:"

            # R√©cup√©ration des variables d'environnement depuis le fichier .env
            if [ -f "${APP_DIR}/.env.dev" ]; then
              source ${APP_DIR}/.env.dev
              DB_USER=${DB_USERNAME:-postgres}
              DB_NAME=${DB_NAME:-Assbt}
            else
              DB_USER="postgres"
              DB_NAME="Assbt"
            fi

            echo "üìä V√©rification des tables dans $DB_NAME avec l'utilisateur $DB_USER"
            docker-compose -f docker-compose.prod.yml exec -T db psql -U $DB_USER -d $DB_NAME -c "\dt" || echo "‚ö†Ô∏è Impossible de v√©rifier les tables"

            # Afficher les logs du service API
            echo "üìÉ Logs du service NestJS:"
            docker-compose -f docker-compose.prod.yml logs --tail=50 api

            # Nettoyage
            echo "üßπ Nettoyage des images inutilis√©es..."
            docker image prune -f